//Написать функцию, которая генерирует на основе двух исходных массивов новый массив.
//В первом массиве содержатся числа, в другом – номера элементов первого массива, которые должны попасть в итоговый.Предусмотреть варианты :
//1) Если во второй массив попали значения, превосходящие размерность первого, необходимо сообщить об этом пользователю и отменить сборку массива
//2) Если во втором массиве встречаются повторяющиеся значения, то соответствующий элемент первого массива включается в новый массив ещё раз

#include<stdio.h>
#include<malloc.h>
#include<locale.h.>
#include<stdlib.h>
#include<time.h>

void scan(int *a)
{
	while ((scanf_s("%9d", &*a) != 1) || (getchar() != 10) )
	{
		printf("\nОшибка, введены некорректные данные.\nПовторите ввод\n");
		rewind(stdin);
	}
}

int main()
{
	setlocale(LC_ALL, "Rus");
	srand(time(NULL));

	int*a, *b, *c,//Указатели на массивы
		d,//Размерность первого массива
		e,//Размерность второго массива
		f;//Переменная выбора способа ввода
		

	{//Заполнение массивов
		puts("Введите размерность первого массива");
		scan(&d);
		puts("Введите размерность второго массива");
		scan(&e);
		if (d < 1 || e < 1) { puts("Размер массива не может быть меньше или равен нулю");_getch();exit(0); }//Завершение программы при неправильном вводе размерностей
		a = (int*)malloc(d*sizeof(int));//Выделение памяти
		b = (int*)malloc(e*sizeof(int));//под исходные массивы
		printf("Выберите способ заполнения массивов\n(1-руками, 0 - автоматически");
		scan(&f);
		switch (f)
		{
		default:puts("Введите нормальное число");_getch();exit(0);
			break;
		case 1:
			puts("Введите первый массив\n");
			for (int i = 0; i < d; i++)
			{
				scan(&a[i]);
			}
			puts("Введите второй массив\n");
			for (int i = 0; i < d; i++)
			{
				scan(&b[i]);
			}
			break;
		case 0:
			for (int i = 0; i < d; i++)
			{
				a[i] = rand() % 200 - 100;printf("%d\t", a[i]);
			}
			puts("\n\n");
			for (int i = 0; i < e; i++)
			{
				b[i] = rand() % 20;printf("%d\t", b[i]);
			}
			break;
		}
	}
	puts("\n\n");
	c = (int*)malloc((d+e)*sizeof(int));//Выделение памяти под новый массив
	int j = 0;
	for (int i = 0; i < d && i<e; i++)//Цикл до конца меньшего из массивов,
	{
		if (b[i] > d) //который прекращается как только значение i-го элемента второго массива превысит размерность первого 
		{ 
			printf("\nНадо бы немедленно прекратить собирать массив, иначе задание не зачтут");break; 
		}
		else //Или продолжается, записав в третий массив элемент первого с индексом, равным соответствующему элементу второго 
		{
			c[j] = a[b[i]];printf("%d\t", c[j]);j++;
		}
	}

	free(a);//Освобождение
	free(b);//Памяти
	free(c);//.

	_getch();
}