//С одномерным динамическим массивом, состоящим из n целочисленных элементов, произвести следующие операции :
//1) найти номер максимального элемента массива;
//2) вычислить произведение элементов массива, расположенных между первым и вторым нулевыми элементами;
//3) преобразовать массив таким образом, чтобы в первой его половине располагались элементы, стоявшие на нечетных позициях, а во второй половине – элементы, стоявшие на четных позициях.
//
//Примечание: Размеры массивов и значения элементов вводятся пользователем.Все операции над массивами выполняются отдельными функциями в том порядке, в котором они описаны в задании.
//В каждой задаче необходимо предусмотреть функцию ввода с клавиатуры одномерного массива.Кроме того, в каждой задаче должна быть реализована проверка на целостность кучи(см.приложение 2).

#include<stdio.h>
#include<malloc.h>
#include<locale.h.>
#include<stdlib.h>
#include<time.h>

void scan(int *a)
{
	while (((scanf_s("%9d", &*a) != 1) || (getchar() != 10)))
	{
		printf("\nОшибка, введены некорректные данные.\nПовторите ввод\n");
		rewind(stdin);
	}
}

int main()
{
	setlocale(LC_ALL, "Rus");
	srand(time(NULL));
	int *a,//Указатель на будущий массив
		b, //Его размерность
		c = -100,//Контрольное значение для поиска максимального элемента
		d,//Запоминает номер максимального элемента в задаче 1
		f;//Для выбора способа ввода

	puts("Введите количество элементов в массиве\n");
	scan(&b);
	if (b<0)
	{
		puts("Размерность массива должна быть положительна");_getch();exit(0);//Выход из программы при вводе некорректного значения
	}
	a = (int*)malloc(b*sizeof(int));//Выделение памяти
	puts("Выберите способ ввода\n(1- руками, 0 - автоматически)\n");
	scan(&f);
	switch (f)
	{
	default:puts("Нет такого способа");_getch();exit(0);
		break;
	case1:
		for (int i = 0; i < b; i++)
		{
			scan(&a[i]);
		}
		break;
	case 0:	
		for (int i = 0; i < b; i++)
	{
		a[i] = rand() % 200 - 100;printf("%d\t", a[i]);
	}
		break;
	}


	//#1
	for (int i = 0; i < b; i++)//Цикл от начала до конца массива
	{
		if (a[i]>c)//Запоминает сам элемент массива и его номер, если он больше чем контрольное значение
		{
			c = a[i];d = i;
		}
	}
	printf("\nНомер максимального значения в массиве равен %d\n", d+1);

	//#2	
	{
	int e = 1;//Запоминает произведение элементов
	int ind1 = -1, ind2 = -1;//Флаги, 
	for (int i = 0; i < b; i++)//которые после прохождения этого цикла примут значения номеров первого и второго нулевых элементов соответственно
	{
		if (a[i] == 0 && ind1 == -1)//Если элемент нулевой и флаг1 еще не принял никаких значений,
		{
			ind1 = i;//то ему присваивается номер элемента
			i++;
		}
		if (a[i] == 0 && ind1 != -1)//Если первый флаг не равен -1, т.е. уже имеет значение, то второму флагу присваивается номер нулевого элемента 
		{
			ind2 = i;
			break;//И цикл завершается
		}
	}
	int dif = ind2 - ind1;//Переменная для более подробного вывода ошибок
	if (dif > 0 && dif < 2)
	{
		printf("Между нулями ничего нет\n");
	}
	if (dif == 2)
	{
		printf("%d\n", a[ind2 - 1]);
	}
	if (ind1 == -1 && ind2 == -1)
	{
		printf("Нулей нет\n");
	}
	if (dif > 2)
	{
		for (int i = ind1 + 1; i < ind2; i++)//Цикл, умножающий элементы между флагами, если dif больше двух
		{
			e = e * a[i];//Непосредственно умножение
		}
		printf("Произведение элементов между нулями равно %d\n", e);//Вывод результата

	}
	if (ind1 != -1 && ind2 == -1)
	{
		printf("Второго нуля нет\n");
	}
	}
	//#3
	int j = 0;
	for (int i = 0; i<b / 2; i++)//Цикл от начала до середины массива
	{
		int buf = a[i];
		for (j = i; j < b - 1; j++) //Цикл от i до конца массива,
		{
			a[j] = a[j + 1];//который смещает все элементы на единицу влево
		}
		a[j] = buf;//присваивание последнему элементу i-го элемента
	}
	
	printf("\n\nПосле перестановки массив выглядит так:\n\n");
	for (int i = 0; i < b; i++)//Вывод полученного массива
	{
		printf("%d\t", a[i]);
	}
	_getch();
}